#!/bin/sh

# Copyright (c) 2010 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

args=""
console="-monitor stdio"
imagesize="16G"
image=""
diskcount=0
memsize=""
verbose=0
tunfd=3     # allocate fd's since -net user will cause them to be off by one
vlancount=0
uid=`id -u`

set -A hexdig 0 1 2 3 4 5 6 7 8 9 a b c d e f

alloc_if() {
	local i=0 type=$1

	# cannot allocate an interface if !root
	if [ uid -ne 0 ]; then
		exit 1
	fi
	# creation is atomic
	while ! ifconfig $type$i create > /dev/null 2>&1
	do
		let i=i+1
	done
	case "$type" in
	tun)
		if ! [ -c /dev/$type$i ]; then
		(
			cd /dev
			sh ./MAKEDEV $type$i
		)
		fi
	;;
	esac
	if [ "$image" ]; then
		bni=$(basename $image)
		if [ verbose -gt 0 ]; then
			echo ifconfig $type$i group ${bni}. > /dev/stderr
		fi
		ifconfig $type$i group ${bni}.
	fi
	echo $type$i
}
alloc_bridge() {
	local name="$1"
	case "$name" in
	group:*)
		g="${name#group:*}"
		# first bridge interface, incase something is wrong and we
		# have multiple interfaces matching the group name
		if=$(ifconfig $g 2>&1|awk \
		   -F: '/^[a-z]/{print $1}'|head -1)
		if ! [ "$if" ]; then
			if=$(alloc_if bridge)
			ifconfig $if group $g
		fi
		bridgeif[$vlancount]=$if
	;;
	*)
		bridgeif[$vlancount]=$(alloc_if bridge)
		bridge[$vlancount]="$name"
	;;
	esac
}

while [ "$1" ]
do
	case "$1" in
	-b)
		alloc_bridge "$2"
		fd[$vlancount]="$tunfd"
		let tunfd=tunfd+1
		let vlancount=vlancount+1
		shift
	;;
	-C) cd="$2"; shift;;
	-c) cd="$2";cdboot=1; shift;;
	-i)
		# ahci is not bootable, so 1st must be ide
		if ! [ "$image" ]; then
			args="$args -hda $2"
			image="$2"
			images="$images $2"
		else
			# 32 is scsibus
			# 4 is observed
			if [ "$((diskcount%4))" -eq 0 ]; then
				args="$args -device ahci,id=ahci$((diskcount/4))"
			fi
			args="$args -drive id=disk$diskcount,file=$2,if=none"
			args="$args -device ide-drive,drive=disk$diskcount,"
			args="${args}bus=ahci$((diskcount/4)).$((diskcount%4))"
			images="$images $2"
			let diskcount=diskcount+1
		fi
		shift
	;;
	-M)
		mode=$(echo $2|sed 's/:.*$//')
		machine=$(echo $2|sed -n '/:/{s/^.*://;p;}')
		shift
	;;
	-m) memsize="-m $2"; shift;;
	-n)
		netcfg[$vlancount]="$2"
		fd[$vlancount]="$tunfd"
		let tunfd=tunfd+1
		let vlancount=vlancount+1
		shift
	;;
	-p)
		tftpdir="$2"
		tftpimg="/pxeboot"
		usernet[$vlancount]=1
		let vlancount=vlancount+1
		shift
	;;
	-s) imagesize="$2"; shift;;
	-o)
		case "$2" in
		bridge*) # bridge=ne0,model=rtl8139,macaddr=52:54:01:00:XX:XX
			for pairs in $(echo "$2" | sed 's/,/ /g')
			do
				rhs=${pairs#*=}
				lhs=${pairs%=*}
				case "$lhs" in
				bridge)
					alloc_bridge $rhs
				;;
				model)
					model[$vlancount]="$rhs"
				;;
				macaddr)
					mac="$rhs"
					while echo "$mac" | grep "XX" > /dev/null 2>&1
					do
						xx=${hexdig[$((RANDOM%16))]}
						xx=$xx${hexdig[$((RANDOM%16))]}
						mac=$(echo "$mac" | sed "s/XX/$xx/")
					done
					macaddr[$vlancount]="$mac"
				;;
				*)
					echo "Oops, $lhs=$rhs unsupported"
				;;
				esac
			done
			fd[$vlancount]="$tunfd"
			let tunfd=tunfd+1
			let vlancount=vlancount+1
		;;
		netcfg*) # netcfg=10.0.7.1/24,model=rtl8139,macaddr=52:54:01:00:XX:XX
			for pairs in $(echo "$2" | sed 's/,/ /g')
			do
				rhs=${pairs#*=}
				lhs=${pairs%=*}
				case "$lhs" in
				netcfg)
					netcfg[$vlancount]="$rhs"
				;;
				model)
					model[$vlancount]="$rhs"
				;;
				macaddr)
					mac="$rhs"
					while echo "$mac" | grep "XX" > /dev/null 2>&1
					do
						xx=${hexdig[$((RANDOM%16))]}
						xx=$xx${hexdig[$((RANDOM%16))]}
						mac=$(echo "$mac" | sed "s/XX/$xx/")
					done
					macaddr[$vlancount]="$mac"
				;;
				*)
					echo "Oops, $lhs=$rhs unsupported"
				;;
				esac
			done
			fd[$vlancount]="$tunfd"
			let tunfd=tunfd+1
			let vlancount=vlancount+1
		;;
		console*) # console=com0,monitor=stdio,serial=stdio
			for pairs in $(echo "$2" | sed 's/,/ /g')
			do
				rhs=${pairs#*=}
				lhs=${pairs%=*}
				case "$lhs" in
				console)
					if [ "$rhs" = "com0" ]; then
						console="-nographic"
					fi
				;;
				monitor)
					console="$console -monitor $rhs"
				;;
				serial)
					console="$console -serial $rhs"
				;;
				*)
					echo "Oops, $lhs=$rhs unsupported"
				;;
				esac
			done
		;;
		esac
		shift
	;;
	-u) user="$2"; shift;;
	-v) let verbose=verbose+1;;
	--) shift;break;;
	*) break;;
	esac
	shift
done


if ! [ "$image" ]; then
	echo "No hard drive image specified, use '-i foo.hda' for example"
	exit 1
fi

for img in $images
do
	if ! [ -e "$img" ]; then
		qemu-img create -f qcow2 $img $imagesize
	fi
done

if [ "$cd" -a -f "$cd" ]; then
	args="$args -cdrom $cd"
else
	if [ "${cd}" != "${cd#ftp://*}" -o "${cd}" != "${cd#http://*}" ]; then
		cdtmpfile=`mktemp /tmp/.qrun.cd.XXXXXXXXXX`
		trap 'rm $cdtmpfile' 0 1 15
		ftp -o $cdtmpfile "$cd" > /dev/null 2>&1 && \
			args="$args -cdrom $cdtmpfile"
	fi
	if [ "$cdboot" ]; then
		args="$args -boot once=d,order=c"
	fi
fi

#args="$args -watchdog i6300esb"
#args="$args -watchdog ib700"
if [ "X$memsize" != "X" ]; then
	args="$args $memsize"
fi
vlan=0
while [ vlan -lt vlancount ]
do
	if [ "${bridgeif[$vlan]}" ]; then
		nicargs="nic,vlan=$vlan"
		if [ "${model[$vlan]}" ]; then
			nicargs="$nicargs,model=${model[$vlan]}"
		fi
		if [ "${macaddr[$vlan]}" ]; then
			nicargs="$nicargs,macaddr=${macaddr[$vlan]}"
		fi
		args="$args -net $nicargs -net tap,vlan=$vlan,fd=${fd[$vlan]}"

		tunif[$vlan]=$(alloc_if tun)
		ifconfig ${tunif[$vlan]} link0
		ifconfig ${tunif[$vlan]} up

		ifconfig ${bridgeif[$vlan]} add ${tunif[$vlan]}
		if [ "${bridge[$vlan]}" ]; then
			ifconfig ${bridgeif[$vlan]} add ${bridge[vlan]}
		fi
		ifconfig ${bridgeif[$vlan]} up
	fi
	if [ "${netcfg[$vlan]}" ]; then
		nicargs="nic,vlan=$vlan"
		if [ "${model[$vlan]}" ]; then
			nicargs="$nicargs,model=${model[$vlan]}"
		fi
		if [ "${macaddr[$vlan]}" ]; then
			nicargs="$nicargs,macaddr=${macaddr[$vlan]}"
		fi
		args="$args -net $nicargs -net tap,vlan=$vlan,fd=${fd[$vlan]}"
		tunif[$vlan]=$(alloc_if tun)
		ifconfig ${tunif[$vlan]} link0
		ifconfig ${tunif[$vlan]} ${netcfg[$vlan]}
		ifconfig ${tunif[$vlan]} up
	fi
	if [ "${usernet[$vlan]}" ]; then
		nicargs="nic,vlan=$vlan"
		if [ "${model[$vlan]}" ]; then
			nicargs="$nicargs,model=${model[$vlan]}"
		fi
		if [ "${macaddr[$vlan]}" ]; then
			nicargs="$nicargs,macaddr=${macaddr[$vlan]}"
		fi
		userargs="user,vlan=$vlan"
		if [ "$tftpdir" ]; then
			userargs="$userargs,tftp=$tftpdir"
			set -A nicmap n o p
			args="$args -boot once=n,order=c"
			args="$args -tftp $tftpdir"
			args="$args -bootp $tftpimg"
		fi
		if [ "$tftpimg" ]; then
			userargs="$userargs,bootfile=$tftpimg"
		fi
		args="$args -net $nicargs -net $userargs"
	fi
	let vlan=vlan+1
done

usbadd="-usb -usbdevice tablet"
qemu="qemu"
case "$mode" in
sparc) qemu="qemu-system-sparc";;
amd64) qemu="qemu-system-x86_64"; args="$args $usbadd -no-fd-bootchk";;
*)     qemu="qemu";               args="$args $usbadd -no-fd-bootchk";;
esac
args="$args $console"
if [ "$machine" ]; then
	args="$args -M $machine"
fi

if [ verbose -gt 0 ]; then
	set -x
fi

rdrargs=""
if [ "$user" ]; then
	chown $user $images
	vlan=0
	while [ vlan -lt vlancount ]
	do
		if [ "${tunif[$vlan]}" ]; then
			rdrargs="$rdrargs -f /dev/${tunif[$vlan]}"
		fi
		let vlan=vlan+1
	done
	fdpass -u $user $rdrargs $qemu $args "$@"
else
	vlan=0
	while [ vlan -lt vlancount ]
	do
		if [ "${tunif[$vlan]}" ]; then
			rdrargs="$rdrargs $((vlan+3))<>/dev/${tunif[$vlan]}"
		fi
		let vlan=vlan+1
	done
	eval $qemu $args "$@" $rdrargs
fi
if [ verbose -gt 0 ]; then
	set +x
fi

(
vlan=0
while [ vlan -lt vlancount ]
do
	if [ "${bridgeif[$vlan]}" ]; then
		[ verbose -gt 0 ] && {
			ifconfig ${bridgeif[$vlan]} > /dev/stderr
			ifconfig ${tunif[$vlan]} > /dev/stderr
		}
		# wait until qemu exits, incase -daemonize is used, to cleanup
		while [ "$(/sbin/ifconfig ${tunif[$vlan]}|grep "status: active")" ]
		do
			sleep $((RANDOM%60+1))
		done
		ifconfig ${bridgeif[$vlan]} del ${tunif[$vlan]}
		[ verbose -gt 0 ] && ifconfig ${bridgeif[$vlan]} > /dev/stderr
	fi

	if [ "${tunif[$vlan]}" ]; then
		# wait until qemu exits, incase -daemonize is used, to cleanup
		while [ "$(fstat /dev/${tunif[$vlan]}| grep -v "^USER")" ]
		do
			sleep $((RANDOM%60+1))
		done
		ifconfig ${tunif[$vlan]} down
		ifconfig ${tunif[$vlan]} destroy
	fi

	if [ "${bridgeif[$vlan]}" ]; then
		# do not destroy a bridge unless there are no more members
		if ! [ "$(ifconfig ${bridgeif[$vlan]}| grep "port [1-9]")" ]
		then
			ifconfig ${bridgeif[$vlan]} down
			ifconfig ${bridgeif[$vlan]} destroy
		fi
	fi
	let vlan=vlan+1
done
)&
